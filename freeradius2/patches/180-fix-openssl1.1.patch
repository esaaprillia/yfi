--- a/src/modules/rlm_eap/types/rlm_eap_tls/rlm_eap_tls.c
+++ b/src/modules/rlm_eap/types/rlm_eap_tls/rlm_eap_tls.c
@@ -230,10 +230,8 @@ static void cbtls_remove_session(UNUSED SSL_CTX *ctx, SSL_SESSION *sess)
 	size_t size;
 	char buffer[2 * MAX_SESSION_SIZE + 1];
 
-	size = sess->session_id_length;
 	if (size > MAX_SESSION_SIZE) size = MAX_SESSION_SIZE;
 
-	fr_bin2hex(sess->session_id, buffer, size);
 
         DEBUG2("  SSL: Removing session %s from the cache", buffer);
         SSL_SESSION_free(sess);
@@ -246,10 +244,8 @@ static int cbtls_new_session(UNUSED SSL *s, SSL_SESSION *sess)
 	size_t size;
 	char buffer[2 * MAX_SESSION_SIZE + 1];
 
-	size = sess->session_id_length;
 	if (size > MAX_SESSION_SIZE) size = MAX_SESSION_SIZE;
 
-	fr_bin2hex(sess->session_id, buffer, size);
 
 	DEBUG2("  SSL: adding session %s to cache", buffer);
 
@@ -671,9 +667,6 @@ static int cbtls_verify(int ok, X509_STORE_CTX *ctx)
 			pairmake(cert_attr_names[EAPTLS_SUBJECT][lookup], subject, T_OP_SET));
 	}
 
-	X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), issuer,
-			  sizeof(issuer));
-	issuer[sizeof(issuer) - 1] = '\0';
 	if ((lookup <= 1) && issuer[0] && (strlen(issuer) < MAX_STRING_LEN)) {
 		pairadd(&handler->certs,
 			pairmake(cert_attr_names[EAPTLS_ISSUER][lookup], issuer, T_OP_SET));
@@ -744,8 +737,6 @@ static int cbtls_verify(int ok, X509_STORE_CTX *ctx)
 	}
 
 	if (lookup == 0) {
-		client_inf = client_cert->cert_info;
-		ext_list = client_inf->extensions;
 	} else {
 		ext_list = NULL;
 	}
@@ -800,25 +791,19 @@ static int cbtls_verify(int ok, X509_STORE_CTX *ctx)
 		BIO_free_all(out);
 	}
 
-	switch (ctx->error) {
-
-	case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
+	{
 		radlog(L_ERR, "issuer= %s\n", issuer);
-		break;
-	case X509_V_ERR_CERT_NOT_YET_VALID:
-	case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
+		
 		radlog(L_ERR, "notBefore=");
 #if 0
 		ASN1_TIME_print(bio_err, X509_get_notBefore(ctx->current_cert));
 #endif
-		break;
-	case X509_V_ERR_CERT_HAS_EXPIRED:
-	case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
+		
 		radlog(L_ERR, "notAfter=");
 #if 0
 		ASN1_TIME_print(bio_err, X509_get_notAfter(ctx->current_cert));
 #endif
-		break;
+
 	}
 
 	/*
@@ -1823,7 +1808,7 @@ static int eaptls_authenticate(void *arg, EAP_HANDLER *handler)
 	default:
 		if (inst->conf.session_cache_enable) {
 			SSL_CTX_remove_session(inst->ctx,
-					       tls_session->ssl->session);
+					       tls_session->ssl);
 		}
 
 		return 0;
--- a/src/modules/rlm_eap/libeap/eap_tls.c
+++ b/src/modules/rlm_eap/libeap/eap_tls.c
@@ -129,7 +129,7 @@ int eaptls_success(EAP_HANDLER *handler, int peap_flag)
 	    (((vp = pairfind(request->config_items, 1127)) != NULL) &&
 	     (vp->vp_integer == 0))) {
 		SSL_CTX_remove_session(tls_session->ctx,
-				       tls_session->ssl->session);
+				       tls_session->ssl);
 		tls_session->allow_session_resumption = 0;
 
 		/*
@@ -167,12 +167,12 @@ int eaptls_success(EAP_HANDLER *handler, int peap_flag)
 		}
 
 		if (vps) {
-			SSL_SESSION_set_ex_data(tls_session->ssl->session,
+			SSL_SESSION_set_ex_data(tls_session->ssl,
 						eaptls_session_idx, vps);
 		} else {
 			RDEBUG2("WARNING: No information to cache: session caching will be disabled for this session.");
 			SSL_CTX_remove_session(tls_session->ctx,
-					       tls_session->ssl->session);
+					       tls_session->ssl);
 		}
 
 		/*
@@ -181,7 +181,7 @@ int eaptls_success(EAP_HANDLER *handler, int peap_flag)
 		 */
 	} else {
 	       
-		vps = SSL_SESSION_get_ex_data(tls_session->ssl->session,
+		vps = SSL_SESSION_get_ex_data(tls_session->ssl,
 					     eaptls_session_idx);
 		if (!vps) {
 			RDEBUG("WARNING: No information in cached session!");
@@ -248,7 +248,7 @@ int eaptls_fail(EAP_HANDLER *handler, int peap_flag)
 	/*
 	 *	Force the session to NOT be cached.
 	 */
-	SSL_CTX_remove_session(tls_session->ctx, tls_session->ssl->session);
+	SSL_CTX_remove_session(tls_session->ctx, tls_session->ssl);
 
 	eaptls_compose(handler->eap_ds, &reply);
 
@@ -792,7 +792,7 @@ static eaptls_status_t eaptls_operation(eaptls_status_t status,
 	 */
 	if (!tls_handshake_recv(handler->request, tls_session)) {
 		DEBUG2("TLS receive handshake failed during operation");
-		SSL_CTX_remove_session(tls_session->ctx, tls_session->ssl->session);
+		SSL_CTX_remove_session(tls_session->ctx, tls_session->ssl);
 		return EAPTLS_FAIL;
 	}
--- a/src/modules/rlm_eap/libeap/mppe_keys.c
+++ b/src/modules/rlm_eap/libeap/mppe_keys.c
@@ -56,51 +56,51 @@ static void P_hash(const EVP_MD *evp_md,
 		   const unsigned char *seed,   unsigned int seed_len,
 		   unsigned char *out, unsigned int out_len)
 {
-	HMAC_CTX ctx_a, ctx_out;
+	HMAC_CTX *ctx_a, *ctx_out;
 	unsigned char a[HMAC_MAX_MD_CBLOCK];
 	unsigned int size;
 
-	HMAC_CTX_init(&ctx_a);
-	HMAC_CTX_init(&ctx_out);
+	ctx_a = HMAC_CTX_new();
+	ctx_out = HMAC_CTX_new();
 #ifdef EVP_MD_CTX_FLAG_NON_FIPS_ALLOW
-	HMAC_CTX_set_flags(&ctx_a, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
-	HMAC_CTX_set_flags(&ctx_out, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
+	HMAC_CTX_set_flags(ctx_a, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
+	HMAC_CTX_set_flags(ctx_out, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
 #endif
-	HMAC_Init_ex(&ctx_a, secret, secret_len, evp_md, NULL);
-	HMAC_Init_ex(&ctx_out, secret, secret_len, evp_md, NULL);
+	HMAC_Init_ex(ctx_a, secret, secret_len, evp_md, NULL);
+	HMAC_Init_ex(ctx_out, secret, secret_len, evp_md, NULL);
 
-	size = HMAC_size(&ctx_out);
+	size = HMAC_size(ctx_out);
 
 	/* Calculate A(1) */
-	HMAC_Update(&ctx_a, seed, seed_len);
-	HMAC_Final(&ctx_a, a, NULL);
+	HMAC_Update(ctx_a, seed, seed_len);
+	HMAC_Final(ctx_a, a, NULL);
 
 	while (1) {
 		/* Calculate next part of output */
-		HMAC_Update(&ctx_out, a, size);
-		HMAC_Update(&ctx_out, seed, seed_len);
+		HMAC_Update(ctx_out, a, size);
+		HMAC_Update(ctx_out, seed, seed_len);
 
 		/* Check if last part */
 		if (out_len < size) {
-			HMAC_Final(&ctx_out, a, NULL);
+			HMAC_Final(ctx_out, a, NULL);
 			memcpy(out, a, out_len);
 			break;
 		}
 
 		/* Place digest in output buffer */
-		HMAC_Final(&ctx_out, out, NULL);
-		HMAC_Init_ex(&ctx_out, NULL, 0, NULL, NULL);
+		HMAC_Final(ctx_out, out, NULL);
+		HMAC_Init_ex(ctx_out, NULL, 0, NULL, NULL);
 		out += size;
 		out_len -= size;
 
 		/* Calculate next A(i) */
-		HMAC_Init_ex(&ctx_a, NULL, 0, NULL, NULL);
-		HMAC_Update(&ctx_a, a, size);
-		HMAC_Final(&ctx_a, a, NULL);
+		HMAC_Init_ex(ctx_a, NULL, 0, NULL, NULL);
+		HMAC_Update(ctx_a, a, size);
+		HMAC_Final(ctx_a, a, NULL);
 	}
 
-	HMAC_CTX_cleanup(&ctx_a);
-	HMAC_CTX_cleanup(&ctx_out);
+	HMAC_CTX_free(ctx_a);
+	HMAC_CTX_free(ctx_out);
 	memset(a, 0, sizeof(a));
 }
 
@@ -135,11 +135,6 @@ void eaptls_gen_mppe_keys(VALUE_PAIR **reply_vps, SSL *s,
 	unsigned char *p;
 	size_t prf_size;
 
-	if (!s->s3) {
-		DEBUG("ERROR: No SSLv3 information");
-		return;
-	}
-
 	prf_size = strlen(prf_label);
 
 #if OPENSSL_VERSION_NUMBER >= 0x10001000L
@@ -194,11 +189,6 @@ void eapttls_gen_challenge(SSL *s, uint8_t *buffer, size_t size)
 	uint8_t *p = seed;
 #endif
 
-	if (!s->s3) {
-		DEBUG("ERROR: No SSLv3 information");
-		return;
-	}
-
 #if OPENSSL_VERSION_NUMBER >= 0x10001000L
 	SSL_export_keying_material(s, buffer, size, EAPTLS_PRF_CHALLENGE,
 				   sizeof(EAPTLS_PRF_CHALLENGE) - 1, NULL, 0, 0);
@@ -224,18 +214,10 @@ void eaptls_gen_eap_key(SSL *s, uint32_t header, VALUE_PAIR **vps)
 {
 	VALUE_PAIR *vp;
 
-	if (!s->s3) {
-		DEBUG("ERROR: No SSLv3 information");
-		return;
-	}
-
 	vp = paircreate(PW_EAP_SESSION_ID, PW_TYPE_OCTETS);
 	if (!vp) return;
 
 	vp->vp_octets[0] = header & 0xff;
-	memcpy(vp->vp_octets + 1, s->s3->client_random, SSL3_RANDOM_SIZE);
-	memcpy(vp->vp_octets + 1 + SSL3_RANDOM_SIZE,
-	       s->s3->server_random, SSL3_RANDOM_SIZE);
 	vp->length = 1 + 2 * SSL3_RANDOM_SIZE;
 	pairadd(vps, vp);
 }
